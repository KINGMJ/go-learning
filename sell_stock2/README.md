# 122. 买卖股票的最佳时机 II

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/

## 题解

### 贪心法

贪心法可以理解为求上升区间问题。

![](http://image.maplejoyous.cn/post/2022/04/04/202204041745088.png)

我们只需要累加每段上升区间的差值即可。

![](http://image.maplejoyous.cn/post/2022/04/04/2022040417465656.png)

所以代码如下：

**`index.go`**

```go
func MaxProfit(prices []int) (ans int) {
	for i := 1; i < len(prices); i++ {
		ans += max(0, prices[i]-prices[i-1])
	}
	return
}
```

### 动态规划

动态规划主要是找出状态转移方程。

考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。

定义状态 `dp[i][0]` 表示第 i 天交易完后手里没有股票的最大利润，`dp[i][1]`表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。

考虑 `dp[i][0]`的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 `dp[i-1][0]`，或者前一天结束的时候手里持有一支股票，即 `dp[i−1][1]`，这时候我们要将其卖出，并获得 `prices[i]` 的收益。因此为了收益最大化，我们列出如下的转移方程：

```go
dp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]}
```

再来考虑 `dp[i][1]`，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 `dp[i−1][1]`，或者前一天结束时还没有股票，即 `dp[i−1][0]`，这时候我们要将其买入，并减少 `prices[i]` 的收益。可以列出如下的转移方程：

```go
dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}
```

对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 `dp[0][0]=0`，`dp[0][1]=−prices[0]`。

因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 `dp[n−1][0]` 的收益必然是大于 `dp[n−1][1]` 的，最后的答案即为 `dp[n−1][0]`。

**`代码见 index1.go`**

#### 优化

注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 `dp[i−1][0]` 和 `dp[i−1][1]` 存放在两个变量中，通过它们计算出 `dp[i][0]` 和 `dp[i][1]` 并存回对应的变量，以便于第 i+1 天的状态转移即可。

**`代码见 index2.go`**

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/
